{
  "hash": "270451c84e6a4a303d72d025e0a3463b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In Class Exercise 10\"\nauthor: \"Qu JunJie\"\ndate: \"10 November 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n  warning: false\n  cache: true\n---\n\n\n# In-class Exercise 10: Working with Open Government Data\n\n## Learning Outcome\n\nBy the end of this hands-on exercise, you will be able to:\n\n-   Preparing data downloaded from REALIS portal for geocoding,\n\n-   Geocoding by using SLA OneMap API,\n\n-   Converting the geocoded transaction data into sf point feature data.frame, and\n\n-   Wrangling the sf point features to avoid overlapping point features.\n\n## Loading the R package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pacman::p_load(tidyverse, sf, tmap, httr, performance)\n```\n:::\n\n\n## Importing data\n\nThe code chunk below imports multiple csv files in a specified folder and append them into a single tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# folder_path <- \"data/aspatial\"\n# file_list <- list.files(path = folder_path, \n#                         pattern = \"^realis.*\\\\.csv$\", \n#                         full.names = TRUE)\n# \n# realis_data <- file_list %>%\n#   map_dfr(read_csv)\n```\n:::\n\n\n## Wrangling data\n\nWrite a code chunk to perform the followings: - converting values in *Sale Date* field from character to numerical date format, and - extracting resale and condominium transaction records.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# condo_resale <- realis_data %>%\n#   mutate(`Sale Date` = dmy(`Sale Date`)) %>%\n#   filter(`Type of Sale` == \"Resale\" &\n#            `Property Type` == \"Condominium\")\n```\n:::\n\n\n## Geocoding\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# postcode <- unique(condo_resale$`Postal Code`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# url <- \"https://onemap.gov.sg/api/common/elastic/search\"\n# found <- data.frame()\n# not_found <- data.frame()\n# \n# for (postcode in postcode){\n#   query <- list('searchVal'=postcode, 'returnGeom'='Y', \n#                 'getAddrDetails'='Y', 'pageNum'='1')\n#   res <- GET(url, query=query)\n#   if ((content(res)$found)!=0){\n#     found <- rbind(found, data.frame(content(res))[4:13])\n#   } else {not_found = data.frame(postcode)\n#   }\n# }\n```\n:::\n\n\n## Tidying field names\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# found <- found %>%\n#   select(c(6:8)) %>%\n#   rename(POSTAL = `results.POSTAL`,\n#          XCOORD = `results.X`,\n#          YCOORD = `results.Y`)\n```\n:::\n\n\n## Converting to Point Feature Data Frame\n\n-   Write a code chunk to join *condo_resale* and *found*. Name the output *condo_resale_geocoded*.\n\n-   Write a code chunk to convert *condo_resale_geocoded* from tibble data frame to sf point feature data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# condo_resale_geocoded = left_join(\n#   condo_resale, found, \n#   by = c('Postal Code' = 'POSTAL'))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# condo_resale_sf <- st_as_sf(condo_resale_geocoded, \n#                             coords = c(\"XCOORD\",\n#                                        \"YCOORD\"),\n#                             crs=3414)\n```\n:::\n\n\n## Cleaning Spatial Data\n\nThe code chunk below is used to check if there are overlapping point features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# overlapping_points <- condo_resale_sf %>%\n#   mutate(overlap = lengths(st_equals(., .)) > 1)\n```\n:::\n\n\nIn the code code chunk below, `st_jitter()` of sf package is used to move the point features by 5m to avoid overlapping point features.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# condo_resale_sf <- condo_resale_sf %>%\n#   st_jitter(amount = 2)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}